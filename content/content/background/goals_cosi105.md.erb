---
title: Learning Objectives
---
This course is called "Software Engineering for Scalability". The word "scale" and "scalability" can be interpretted in several ways: Scale as in number of users, scale as in amount of code, scale as in number of developers, and scale in terms of how long the system is expected to live.

Consequently the course is divided into three:

* **Scalable Architecture**: How to design a system so that it will scale to many many users, transactions, databases and so on. We would like to develop your nose for scaling problems: where they may arise, how to identify architeture or behavior which can lead to scaling problems; and a series of available architetural patterns known to address these.

* **Scalable Design**: How to design software so that it can evolve and survive over the years. We would like to develop your sense of good software design, good object oriented design; identifying and solving code smells. How to take a problem statement and think through the objects and relationships between them in order to design the best possible design given time and requirements.

* **Applied Software Engineering**: Use what you learn in a real-world team based development project. Starting from scratch, with a team of other students, you will design, implement, test, and deploy your own version of Twitter. You will be asked to load it up with users, measure its performance and then using techniques learned here to improve its performance and scalability.

#### Some specific topics

##### Learn: Scalable Architecture
* Protocols and formats: http, html, urls
* How web servers work
* Architectural concepts for scale
* Data Modeling for application design
* Databases: SQL, NoSQL
* Caching
* Sharding
* Concurrency
* Logging
* Deploying
* Load testing
* Application performance analysis

##### Learn: Scalable Design
* Best practices in Software Engineering
* Object Oriented Design
* Domain Objects
* Relationships
* Test Driven Design and testing
* Refactoring

##### Do: Applied Software Engineering
* Write excellent Ruby
* Write and deploy a Sinatra application
* Deploy to the cloud (Heroku)
* Generate and analyze a load and monitor performance
